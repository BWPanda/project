<?php

define('PROJECT_RELEASE_FILE_EXTENSIONS', 'zip gz tar bz2 rar tgz tar.gz dmg rpm deb');

/**
 * Constants for the possible values of $node->project_release['update_status'].
 */
define('PROJECT_RELEASE_UPDATE_STATUS_CURRENT', 'current');
define('PROJECT_RELEASE_UPDATE_STATUS_NOT_CURRENT', 'not-current');
define('PROJECT_RELEASE_UPDATE_STATUS_NOT_SECURE', 'not-secure');

/**
 * @defgroup project_release_core Core Backdrop hooks
 */

/**
 * Implementation of hook_init().
 */
function project_release_init() {
  // These constants are defined here since they use t() and the global $locale
  // variable needs to be initialized before calling t() or you suffer a big
  // performance hit.
  define('PROJECT_RELEASE_VERSION_FORMAT_VALID_MSG', t('The version format string can only contain letters, numbers, and the characters . _ and - (in addition to the special characters used for identifying variables: % ! and #).'));
  define('PROJECT_RELEASE_VERSION_FORMAT_HELP', t("<p>Used to parse and validate version numbers. Available variables are <code>api</code>, <code>major</code>, <code>minor</code>, <code>patch</code>, and <code>extra</code>. Variable prefixes translate to delimiters:</p>
<table>
  <tr><th>Prefix</th><th>Delimiter</th></tr>
  <tr><td><code>%</code></td><td><code>.</code></td></tr>
  <tr><td><code>#</code></td><td><code>-</code></td></tr>
  <tr><td><code>!</code></td><td><em>none</em></td></tr>
</table>
<p>For example, <code>!major%minor#patch</code> will accept <code>[major][.minor][-patch]</code>, such as <code>2.3-4</code>. Any variable in the format string may be omitted in the version number.</p>") .' <p>'. PROJECT_RELEASE_VERSION_FORMAT_VALID_MSG . '</p>');
}

/**
 * Implementation of hook_menu().
 * @ingroup project_release_core
 */
function project_release_menu() {
  $items = array();

  $items['node/%project/edit/releases'] = array(
    'title' => 'Releases',
    'page callback' => 'project_release_project_edit_releases',
    'page arguments' => array(1),
    'access callback' => 'node_access',
    'access arguments' => array('update', 1),
    'type' => MENU_LOCAL_TASK,
    'file' => 'project_release.pages.inc',
  );
  $items['admin/config/project/releases'] = array(
    'title' => t('Project release settings'),
    'description' => t('Configure system-wide settings for the Project Release module.'),
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('project_release_settings_form'),
    'access callback' => 'user_access',
    'access arguments' => array('administer projects'),
    'file' => 'project_release.admin.inc',
  );

  return $items;
}

/**
 * Implementation of hook_menu_alter().
 */
function project_release_menu_alter(&$callbacks) {
  foreach (project_release_release_node_types() as $release_type) {
    $type_url_str = str_replace('_', '-', $release_type);

    // Add project-specific node add callback.
    $callbacks['node/add/' . $type_url_str . '/%project'] = $callbacks['node/add/' . $type_url_str];
    $callbacks['node/add/' . $type_url_str . '/%project']['access callback'] = 'project_user_access';
    $callbacks['node/add/' . $type_url_str . '/%project']['access arguments'] = array(3, 'administer releases');

    // @todo: Provide a fallback page for adding project releases.
    $callbacks['node/add/' . $type_url_str]['page callback'] = FALSE;
  }
}

/**
 * Verifies the data for supported release versions, and updates if necessary.
 *
 * @param $pid
 *   The project ID.
 * @param $version_api
 *   The API compatibility string.
 * @param $version_major
 *   The major version of the new/modified/deleted release.
 * @param $delete
 *   Boolean to indicate if we're deleting a release of this major or not.
 *
 * @return
 *   TRUE if we updated a record in {project_release_supported_versions},
 *   otherwise FALSE (e.g. if there were no published releases on the
 *   requested branch).
 */
function project_release_check_supported_versions($pid, $version_api, $version_major, $delete = FALSE) {
  // Remember if we updated {project_release_supported_versions} so we can
  // return the value to our caller.
  $did_update = FALSE;

  // If we're being called as a release node is being edited and saved, and
  // the site we're running on is using DB replication, we need to make sure
  // we're talking to the primary DB so that all of this works.
  db_ignore_slave();

  // Regardless of if we're deleting, adding, or editing, we need to know the
  // latest and recommended releases (if any) from the given branch. If
  // there's no published release, these values will be 0.
  list($latest_release, $recommended_release, $latest_security_release) = project_release_find_latest_releases($pid, $version_api, $version_major);

  if ($delete) {
    // Make sure this isn't the last release node for the given major.
    if (!empty($latest_release)) {
      // Since the node we just deleted might have been the latest or
      // recommended on the branch, update our record with the real values.
      db_update('project_release_supported_versions')
        ->fields(array(
          'recommended_release' => $recommended_release,
          'latest_release' => $latest_release,
          'latest_security_release' => $latest_security_release,
        ))
        ->condition('nid', $pid)
        ->condition('version_api', $version_api)
        ->condition('version_major', $version_major)
        ->execute();
      $did_update = TRUE;
    }
    else {
      // No latest release -- remove the bogus record for this branch.
      db_delete('project_release_supported_versions')
        ->condition('nid', $pid)
        ->condition('version_api', $version_api)
        ->condition('version_major', $version_major)
        ->execute();

      $num_recommended = db_select('project_release_supported_versions', 'psrv')
        ->condition('psrv.nid', $pid)
        ->condition('psrv.version_api', $version_api)
        ->condition('psrv.supported', 1)
        ->condition('psrv.recommended', 1)
        ->countQuery()->execute()->fetchField();
      if ($num_recommended > 1) {
        // Something seriously bogus, clear out the values and start over.
        db_update('project_release_supported_versions')
          ->fields(array(
            'recommended' => 0,
          ))
          ->condition('nid', $pid)
          ->condition('version_api', $version_api)
          ->execute();
      }
    }
  }
  else {
    // Adding or editing a release.
    if (!empty($latest_release)) {
      // We have at least 1 published release, so make sure we have an entry
      // for this major version in {project_release_supported_versions}.
      $query = db_select('project_release_supported_versions', 'psrv')
        ->fields('psrv', array('major'))
        ->condition('psrv.nid', $pid)
        ->condition('psrv.version_api', $version_api);
      $have_current_branch = FALSE;
      $num_branches = 0;
      foreach ($query->execute() as $branch) {
        $num_branches++;
        if ($branch->major == $version_major) {
          $have_current_branch = TRUE;
          break;
        }
      }
      if ($num_branches == 0 || !$have_current_branch) {
        // First entry for this API tid/major version pair, so add a new
        // record to the table as supported but not recommended.
        db_insert('project_release_supported_versions')
          ->fields(array(
            'nid' => $pid,
            'version_api' => $version_api,
            'version_major' => $version_major,
            'supported' => 1,
            'recommended' => 0,
            'snapshot' => 0,
            'recommended_release' => $recommended_release,
            'latest_release' => $latest_release,
            'latest_security_release' => $latest_security_release,
          ))
          ->execute();
      }
      else {
        // We already have this branch in the table, but the latest_release
        // and recommended_release fields might be stale based on whatever
        // node was just added or edited.
        db_update('project_release_supported_versions')
          ->fields(array(
            'recommended_release' => $recommended_release,
            'latest_release' => $latest_release,
            'latest_security_release' => $latest_security_release,
          ))
          ->condition('nid', $pid)
          ->condition('version_api', $version_api)
          ->condition('version_major', $version_major)
          ->execute();
      }
      $did_update = TRUE;
    }
  }

  // Regardless of insert/edit/delete, we want to go through and recompute
  // $node->project_release['update_status'] for all records on this branch.
  // Note: we end up doing the same query in here that we performed in
  // project_release_find_latest_releases(), we just need to process the
  // results differently. However, to keep the code sane, we invoke the query
  // again. If this becomes a performance problem, we can always refactor.
  project_release_compute_update_status($pid, $version_api, $version_major);

  return $did_update;
}

/**
 * Compute the $node->project_release['update_status'] values for a branch.
 *
 * For any given release node, there are three possible status values for if
 * the release needs an update or not:
 * - 'current' (PROJECT_RELEASE_UPDATE_STATUS_CURRENT): It's the currently
 *   recommended release (without extra), or the latest possible release
 *   (including betas, rcs, etc). There is no need to upgrade this release at
 *   this time, it's the most up-to-date available.
 * - 'not-current' (PROJECT_RELEASE_UPDATE_STATUS_NOT_CURRENT): Any release
 *   older than the recommended release, or any older release with extra from
 *   the same major/minor/patch as the latest release.
 * - 'not-secure' (PROJECT_RELEASE_UPDATE_STATUS_NOT_SECURE): Any release
 *   older than the latest security update on this branch is considered not
 *   secure. Releases are only marked 'not-secure' on sites that define the
 *   'project_release_security_update_tid' variable.
 *
 *  For example, if 1.2.2 is the recommended release, 1.2.1 was a security
 *  update, and 1.2.2-beta2 is the latest release, here would be the following
 *  update status values for various releases:
 *  - 1.2.2-beta2: 'current'     (since it's the latest release)
 *  - 1.2.2-beta1: 'not-current' (since beta2 is available)
 *  - 1.2.2: 'current'           (recommended release, latest without "extra")
 *  - 1.2.2-rc1: 'not-current'   (since 1.2.2 official is out)
 *  - 1.2.1: 'not-current'
 *  - 1.2.1-beta1: 'not-secure'  (since 1.2.1 official was a security update)
 *  - 1.2.0: 'not-secure'
 *
 * This status is recorded in the {project_release}.update_status field in the
 * database. Whenever a release is created, updated, or deleted, we need to
 * inspect all the other releases on the same branch to potentially modify the
 * update_status column as needed.
 *
 * This function walks through all the release nodes matching the given branch
 * (API compatibility term ID and major version) for a specified project in
 * version order (as determined by project_release_query_releases()
 * which sorts by version_minor, version_patch, version_extra_weight and
 * finally version_extra), and compares them with that branch's latest release,
 * recommended release, and latest security release to compute their update
 * status. If the release is the latest or recommended, it's 'current'.
 * Otherwise, it's 'not-current' if we haven't passed a security update yet, or
 * 'not-secure' once we find a security update.
 *
 * Note that releases which are rebuilt (e.g. -dev releases) always show up
 * last (so that we do the right thing when looking for latest official,
 * recomm ended and security releases) but those are always current, so we
 * need to special-case those.
 *
 * @param $pid
 *   The project ID.
 * @param $version_api
 *   The API compatibility string.
 * @param $version_major
 *   The major version of the new/modified/deleted release.
 * @param $regenerate
 *   Flag indicating whether to regenerate the project_release download table.
 *   Defaults to TRUE.
 *
 * @return
 *   Void. This function directly updates {project_release}.update_status with
 *   the appropriate values.
 *
 * @see project_release_check_supported_versions()
 * @see project_release_query_releases()
 * @see project_release_release_nodeapi()
 */
function project_release_compute_update_status($pid, $version_api, $version_major, $regenerate = TRUE) {
  $latest_release = $recommended_release = $latest_security_release = 0;
  $insecure_nids = array();
  // $version_api can also be false or the empty string.
  if ($version_api == '') {
    $version_api = NULL;
  }

  foreach (project_release_query_releases($pid, $version_api, $version_major) as $release) {
    // Clear out the status so we always start fresh with each release.
    unset($update_status);
    if (empty($latest_release)) {
      $latest_release = $release->nid;
      // If this is the latest release, it's current.
      $update_status = PROJECT_RELEASE_UPDATE_STATUS_CURRENT;
    }
    if (empty($recommended_release) && empty($release->project_release['version_extra'])) {
      $recommended_release = $release->nid;
      // If this is the recommended release, it's current.
      $update_status = PROJECT_RELEASE_UPDATE_STATUS_CURRENT;
    }
    if (empty($latest_security_release) && project_release_is_security_update($release)) {
      $latest_security_release = $release->nid;
    }

    // Based on what we've already seen, figure out the status. The only
    // possible releases that can be "CURRENT" are the latest and recommended
    // releases (and -dev releases which rebuild), and we already set the
    // status for those. So, if we're here, we know it's not current, we just
    // need to know if it's also not secure.
    if (!isset($update_status)) {
      // If we haven't found a security release yet, or the release we're on
      // is the latest security update, this is just 'not_current'.
      if (empty($latest_security_release) || $latest_security_release == $release->nid) {
        $update_status = PROJECT_RELEASE_UPDATE_STATUS_NOT_CURRENT;
      }
      // Otherwise, we're past the latest security release, this is insecure.
      else {
        $update_status = PROJECT_RELEASE_UPDATE_STATUS_NOT_SECURE;
      }
    }

    // Allow modification of update status.
    backdrop_alter('project_release_update_status', $update_status, $release);

    // If the status is different than what we have in the DB, update it.
    if (empty($release->project_release['update_status']) || $update_status != $release->project_release['update_status']) {
      $release->project_release['update_status'] = $update_status;
      node_save($release);

      if ($update_status === PROJECT_RELEASE_UPDATE_STATUS_NOT_SECURE) {
        $insecure_nids[] = $release->nid;
      }
    }
  }

  if (!empty($insecure_nids) && module_exists('project_package')) {
    project_package_check_update_status($insecure_nids);
  }

  // Regenerate the download table.
  if ($regenerate) {
    project_release_download_table($pid, TRUE);
  }
}

/**
 * Compute the project_release['update_status'] for multiple branches.
 *
 * This function is a wrapper for project_release_compute_update_status(),
 * facilitating the update status computation for multiple branches via a
 * single function call.
 *
 * @param $pid
 *   The project id.
 * @param $updates
 *   An array of branches to be passed to project_release_compute_update_status
 *   where each branch is itself an array with a single '$api_tid' => '$major'
 *   element.
 *
 * @see project_release_compute_update_status()
 */
function project_release_compute_update_status_multiple($pid, $updates) {
  $keys = array_keys($updates);
  $last_key = end($keys);
  foreach ($updates as $key => $update) {
    $regen = $key == $last_key ? TRUE : FALSE;
    project_release_compute_update_status($pid, $update['api_tid'], $update['major'], $regen);
  }
}

/**
 * Implements hook_form_FORM_ID_alter() for release node forms.
 */
function project_release_form_node_form_alter(&$form, &$form_state) {
  $node = $form_state['node'];
  if (project_node_is_project($node)) {
    $form['project']['releases_enabled'] = array(
      '#type' => 'checkbox',
      '#title' => t('Enable releases'),
      '#description' => t('Projects that have releases may add versioned, downloadable files attached to them.'),
      '#default_value' => $node->project['releases_enabled'],
    );
  }
  if (project_release_node_is_release($node)) {
    $project_node = node_load(project_release_get_release_project_nid($node));
    if (!$project_node->project['releases_enabled']) {
      backdrop_set_message(t('!project does not have project releases enabled.', array('!project' => l($project_node->title, 'node/' . $project_node->nid))), 'warning');
      $form['#access'] = FALSE;
    }

    // Title is set programmatically in project_release_node_validate().
    $form['title']['#access'] = FALSE;

    $form['project_release'] = array(
      '#type' => 'markup',
      '#tree' => TRUE,
    );

    $api_versions = config_get('project_release.settings', 'api_versions');
    if (!empty($api_versions)) {
      $version_description = t('Enter the full version string for this release, including any API version prefix. e.g. 1.x-2.0.1');
    }
    else {
      $version_description = t('Enter the full version string for this release. e.g. 2.0.1');
    }
    $form['project_release']['version'] = array(
      '#type' => 'textfield',
      '#size' => 14,
      '#title' => t('Version string'),
      '#default_value' => $node->project_release['version'],
      '#description' => $version_description,
    );
    $form['project_release']['version_api'] = array(
      '#type' => 'select',
      '#title' => t('API Version'),
      '#options' => backdrop_map_assoc($api_versions),
      '#access' => !empty($api_versions),
    );
    $form['project_release']['security_update'] = array(
      '#type' => 'checkbox',
      '#title' => t('Security release'),
      '#default_value' => $node->project_release['security_update'],
    );
    $form['project_release']['release_link'] = array(
      '#type' => 'url',
      '#title' => t('Release link'),
      '#default_value' => $node->project_release['release_link'],
      '#description' => t('The URL to the release notes for this release.'),
    );
    $form['project_release']['download_link'] = array(
      '#type' => 'url',
      '#title' => t('Download link'),
      '#default_value' => $node->project_release['download_link'],
      '#description' => t('The URL to an archive containing this release.'),
    );
  }
}

/**
 * Implements hook_node_load().
 */
function project_release_node_load($nodes, $types) {
  $project_release_nids = array();
  foreach ($nodes as $node) {
    if (project_release_node_is_release($node)) {
      $project_release_nids[] = $node->nid;
    }
  }
  if ($project_release_nids) {
    $result = db_select('project_release', 'pr')
      ->fields('pr')
      ->condition('nid', array_keys($nodes))
      ->execute();
    foreach ($result as $row) {
      $project_release_data = (array) $row;
      unset($project_release_data['nid']);
      $nodes[$row->nid]->project_release = $project_release_data;
    }
  }
}

/**
 * Implements hook_node_prepare().
 */
function project_release_node_prepare(Node $node) {
  if (project_node_is_project($node)) {
    // Set default project values.
    $node->project += array(
      'releases_enabled' => 1,
    );
  }
  if (project_release_node_is_release($node) && empty($node->project_release)) {
    // Set default project release values.
    $node->project_release = array(
      'version' => NULL,
      'project_nid' => NULL,
      'tag' => NULL,
      'version_api' => NULL,
      'version_major' => NULL,
      'version_minor' => NULL,
      'version_patch' => NULL,
      'version_extra' => NULL,
      'security_update' => FALSE,
      'release_link' => '',
      'download_link' => '',
    );
  }
}

/**
 * Implements hook_node_validate().
 */
function project_release_node_validate(&$node, $form, &$form_state) {
  if (project_release_node_is_release($node)) {
    $project = node_load(project_release_get_release_project_nid($node));

    // Make sure version is unique per-project.
    $version = $node->project_release['version'];
    $existing_nid = project_release_exists($project->nid, $version);
    if ($existing_nid !== FALSE && $existing_nid != $node->nid) {
      form_error($form['project_release']['version'], t('Version %version already exists for %project.', array('%version' => $version, '%project' => $project->title)));
    }

    // Validate version.
    if (empty($node->project_release_preserve_version_elements)) {
      if (project_release_parse_version($node) === FALSE) {
        form_error($form['project_release']['version'], t('Version does not match the required format.'));
      }
    }

    // Set release title.
    form_set_value($form['title'], $project->project['name'] . ' ' . $form_state['values']['project_release']['version'], $form_state);
  }
}

/**
 * Implements hook_node_presave().
 */
function project_release_node_presave($node) {
  if (project_release_node_is_release($node)) {
    // For new release nodes,
    if (empty($node->nid)) {
      // set project using the menu-loaded node.
      $project = menu_get_object('project', 3);
      $node->project_release['project_nid'] = $project->nid;
    }

    // Save version information.
    if (empty($node->project_release_preserve_version_elements)) {
      // Only recalculate version components if changed.
      if (!isset($node->original) || $node->project_release['version'] !== $node->original->project_release['version']) {
        $version_elements = project_release_parse_version($node);
      }
    }
    elseif (is_array($node->project_release_preserve_version_elements)) {
      $version_elements = $node->project_release_preserve_version_elements;
      unset($node->project_release_preserve_version_elements);
    }
    if (!empty($version_elements)) {
      foreach ($version_elements as $part => $value) {
        if (($part === 'patch' || $part === 'major' || $part === 'minor') && !is_numeric($value)) {
          // If the patch, major, or minor fields are set to a non-numeric
          // value, keep it as a NULL in the DB, instead of casting it to a 0.
          $node->project_release['version_'  . $part] = NULL;
        }
        else {
          $node->project_release['version_'  . $part] = $value;
        }
      }
    }
  }
}

/**
 * Implements hook_node_insert().
 */
function project_release_node_insert(Node $node) {
  _project_release_node_save($node);
}

/**
 * Implements hook_node_update().
 */
function project_release_node_update(Node $node) {
  _project_release_node_save($node);
}

/**
 * Shared callback for hook_node_insert() and hook_node_update().
 */
function _project_release_node_save(Node $node) {
  if (project_release_node_is_release($node)) {
    $record = array('nid' => $node->nid) + $node->project_release;
    $update_keys = !empty($node->original->project_release['project_nid']) ? array('nid') : array();
    backdrop_write_record('project_release', $record, $update_keys);
    // Update supported versions on shutdown.
    backdrop_register_shutdown_function('project_release_check_supported_versions', project_release_get_release_project_nid($node), $node->project_release['version_api'], $node->project_release['version_major'], TRUE);
  }
}

/**
 * Implements hook_node_delete().
 */
function project_release_node_delete($node) {
  if (project_release_node_is_release($node)) {
    // Update supported versions on shutdown.
    backdrop_register_shutdown_function('project_release_check_supported_versions', project_release_get_release_project_nid($node), $node->project_release['version_api'], $node->project_release['version_major'], TRUE);
  }
}

/**
 * Implements hook_node_view().
 */
function project_release_node_view($node, $view_mode, $langcode) {
  if (project_node_is_project($node)) {
    if (!empty($node->project['releases_enabled']) && $view_mode !== 'rss' && $view_mode !== 'search_index') {
      // Add releases table and links.
      $node->content['project_release_downloads'] = array(
        '#prefix' => '<h3>' . t('Downloads') . '</h3>',
        '#weight' => 10,
        'table' => array(
          '#markup' => project_release_download_table($node->nid),
        ),
        'links' => array(
          '#theme' => 'links',
          '#links' => array(
            'view_all_releases' => array('title' => t('View all releases'), 'href' => 'node/' . $node->nid . '/release'),
          ),
        ),
      );
      if (project_user_access($node->nid, 'administer releases')) {
        $types = project_release_release_node_types();
        // todo this uses the first release node type. What to do if there are
        // multiple?
        $node->content['project_release_downloads']['links']['#links']['add_new_release'] = array(
          'title' => t('Add new release'), 'href' => 'node/add/' . str_replace('_', '-', reset($types)) . '/' . $node->nid,
        );
        $node->content['project_release_downloads']['links']['#links']['administer_releases'] = array(
          'title' => t('Administer releases'), 'href' => 'node/' . $node->nid . '/edit/releases',
        );
      }
    }
  }
  elseif (project_release_node_is_release($node)) {
    $project = node_load(project_release_get_release_project_nid($node));

    if ($view_mode === 'full') {
      project_project_set_breadcrumb($project, TRUE, array(l(t('Releases'), 'node/' . $project->nid . '/release')));
    }

    // Add "Release notes" header.
    if (isset($node->content['body'])) {
      $node->content['body']['#prefix'] = '<h3>' . t('Release notes') . '</h3>';
    }

    // Replace files with a view.
    //list($view_name, $display_name) = explode(':', variable_get('project_release_files_view', 'project_release_files:default'));
    //$node->content['field_release_files'] = array('#markup' => views_embed_view($view_name, $display_name, $node->nid));

    // Last updated release file.
    //if (!empty($node->field_release_files)) {
    //  $files = array_map('field_collection_field_get_entity', $node->field_release_files[$node->language]);
    //  $max_file_timestamp = 0;
    //  foreach ($files as $file) {
    //    if (array_key_exists('timestamp', $file->field_release_file[$node->language][0])) {
    //      $max_file_timestamp = max($max_file_timestamp, $file->field_release_file[$node->language][0]['timestamp']);
    //    }
    //  }
    //  if ($max_file_timestamp > 0) {
    //    $node->content['field_release_files']['#suffix'] = '<div class="last-updated">' . t('Last updated: !changed', array('!changed' => format_date($max_file_timestamp))) . '</div>';
    //  }
    //}

    //$rebuild_version = db_query("SELECT rebuild_version FROM {project_release_node_rebuild_metadata} WHERE nid = :nid", array(':nid' => $node->nid))->fetchField();
    //if (!empty($rebuild_version)) {
    //  $suffix = '<div class="rebuild-version">' . t('Last packaged version: @rebuild_version', array('@rebuild_version' => $rebuild_version)) . '</div>';
    //  if (empty($node->content['field_release_files']['#suffix'])) {
    //    $node->content['field_release_files']['#suffix'] = $suffix;
    //  }
    //  else {
    //    $node->content['field_release_files']['#suffix'] .= $suffix;
    //  }
    //}

    //// If the release node has a file, include an enclosure attribute for it.
    //if ($view_mode === 'rss' && isset($files)) {
    //  // RSS will only take the first file.
    //  $url = field_view_value('field_collection_item', $files[0], 'field_release_file', $files[0]->field_release_file[$node->language][0], array('type' => 'file_url_plain'));
    //  $node->rss_elements[] = array(
    //    'key' => 'enclosure',
    //    'attributes' => array(
    //      'url' => backdrop_render($url),
    //      'length' => $files[0]->field_release_file[$node->language][0]['filesize'],
    //      'type' => 'application/octet-stream',
    //    ),
    //  );
    //}
  }
}

/**
 * Implements hook_node_type_load().
 */
function project_release_node_type_load(&$types) {
  $additions = array(
    'project_release_version_format' => '!api#major%minor%patch#extra',
  );
  foreach ($types as $type_name => $type) {
    $types[$type_name]->settings += $additions;
  }
}

/**
 * Get the project nid of a release's project node.
 *
 * @param $node
 *   A release node object.
 *
 * @return integer
 *   A node ID.
 */
function project_release_get_release_project_nid($node) {
  $item = menu_get_item();
  if ($item['path'] === 'node/add/project-release/%') {
    // The field is not set until the release node is saved.
    $project = menu_get_object('project', 3);
    return $project->nid;
  }

  if (!isset($node->project_release['project_nid'])) {
    // Reload node since not all properties are set during node form submit.
    $node = node_load($node->nid);
  }

  return $node->project_release['project_nid'];
}

/**
 * Find and parse the version format string for a release.
 *
 * The format string is set for the release node type, and may be overridden by
 * a specific project.
 *
 * @param $release
 *   A release node object.
 *
 * @return
 *   The version format string tokenized into an array. Each value is either:
 *   - A string, that literal string should appear in the version.
 *   - An associative array:
 *     - 'delimiter' => either '.', '-', or ''
 *     - 'label' => either 'api', 'major', 'minor', 'patch', or 'extra'
 *     The version should contain the delimiter followed by the value to be
 *     assigned to the label.
 */
function project_release_get_version_format($release) {
  $project_node = node_load(project_release_get_release_project_nid($release));

  // Get the version format from the project or node type default.
  if (empty($project_node->project['release_version_format'])) {
    $node_type = node_type_get_type($release->type);
    $format_string = $node_type->settings['project_release_version_format'];
  }
  else {
    $format_string = $project_node->project['release_version_format'];
  }

  // Parse format string.
  $delimiters = array(
    '%' => '.',
    '#' => '-',
    '!' => '',
  );
  $delimiter = NULL;
  $format = array();
  foreach (preg_split('/([!#%])(api|major|minor|patch|extra)/', $format_string, -1, PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY) as $token) {
    if (is_null($delimiter)) {
      // Previous token was not a delimiter.
      if (isset($delimiters[$token])) {
        // Save delimiter to go with the next token.
        $delimiter = $delimiters[$token];
      }
      else {
        // Token is just a string.
        $format[] = $token;
      }
    }
    else {
      // Previous token was a delimiter, save delimiter and label.
      $format[] = array(
        'delimiter' => $delimiter,
        'label' => $token,
      );
      $delimiter = NULL;
    }
  }

  return $format;
}

/**
 * Parse a release node's version string.
 *
 * @param $node
 *   A release node object.
 *
 * @return
 *   If the string is invalid, FALSE. Otherwise, an array with the version
 *   components.
 */
function project_release_parse_version($node) {
  $regexp = '/^';
  $components = array('full');
  foreach (project_release_get_version_format($node) as $part) {
    if (is_array($part)) {
      // Optional non-capturing group with delimiter, since each part is
      // optional. Followed by a capturing group to extract the actual parts.
      $regexp .= '(?:' . preg_quote($part['delimiter']) . '(';
      switch ($part['label']) {
        case 'api':
          // Match the selected API compatibility.
          if (isset($node->project_release['version_api'])) {
            $regexp .= preg_quote($node->project_release['version_api']);
          }
          break;

        case 'major':
        case 'minor':
          // An integer.
          $regexp .= '[0-9]+';
          break;

        case 'patch':
          // An integer or 'x'.
          $regexp .= '[0-9]+|x';
          break;

        case 'extra':
          // Anything.
          $regexp .= '.+';
          break;
      }
      $regexp .= '))?';
      $components[] = $part['label'];
    }
    else {
      $regexp .= preg_quote($part);
    }
  }
  $regexp .= '$/';

  if (preg_match($regexp, $node->project_release['version'], $match)) {
    $version = array_merge(
      // Provide default values so something is always saved.
      array(
        'major' => NULL,
        'minor' => NULL,
        'patch' => NULL,
        'extra' => NULL,
        'ext_weight' => NULL,
        'ext_delta' => NULL,
      ),
      // Map $match to named keys.
      array_combine($components, array_pad($match, count($components), ''))
    );
    if (!empty($version['extra'])) {
      // Since we have extra defined, see what the weight should be, based on
      // our current mapping of version_extra prefixes to weights.
      $extra_meta = project_release_parse_version_extra($version['extra']);
      $version['ext_weight'] = $extra_meta['weight'];
      $version['ext_delta'] = $extra_meta['delta'];
    }
    return $version;
  }
  return FALSE;
}

/**
 * Parse an 'extra' element from the version and set the related values.
 *
 * @param string $version_extra
 *   The 'extra' version element (e.g. 'alpha10')
 *
 * @return array
 *   An associative array, keyed by 'weight' and 'delta'.
 */
function project_release_parse_version_extra($version_extra) {
  $extra_meta = array(
    'weight' => 0,
    'delta' => 0,
  );
  // Find the weight based on the current weight map.
  foreach (project_release_get_version_extra_weight_map() as $prefix => $weight) {
    // If extra starts with $prefix.
    if (strpos($version_extra, $prefix) === 0) {
      $extra_meta['weight'] = $weight;
      break;
    }
  }
  // If version_extra contains any digits, save them. This is used to
  // ensure that alpha10 is considered "newer" than alpha9.
  if (preg_match('/(\d+)/', $version_extra, $match)) {
    $extra_meta['delta'] = $match[1];
  }
  return $extra_meta;
}

/**
 * Get the download table for a project.
 *
 * @param $pid
 *   Project node ID.
 * @param $_clear
 *   TRUE to force regenerating the cache.
 */
function project_release_download_table($pid, $_clear = FALSE) {
  if ($_clear || ($cache = cache_get($pid, 'cache_project_release_download_table')) === FALSE) {
    $output = views_embed_view('project_release_download_table', 'recommended', $pid);
    cache_set($pid, $output, 'cache_project_release_download_table');
    return $output;
  }
  return $cache->data;
}

/**
 * Handle rewriting a file URI with a download base.
 *
 * @param $uri
 *   String file URI, like 'public://...'
 * @param $download_base
 *   String download_base variable.
 *
 * @return
 *   The rewritten file URI.
 */
function project_release_add_download_base($uri, $download_base) {
  if ($wrapper = file_stream_wrapper_get_instance_by_uri($uri)) {
    // Parsing pulled from BackdropPublicStreamWrapper::getExternalUrl(),
    // whose protected methods we can not call.
    list($scheme, $target) = explode('://', $wrapper->getUri(), 2);
    $uri = $download_base . $wrapper->getDirectoryPath() . '/' . str_replace('\\', '/', trim($target, '\/'));
  }
  return $uri;
}

function theme_project_release_update_status($variables) {
  $update_status = $variables['update_status'];
  $status_list = array(
    PROJECT_RELEASE_UPDATE_STATUS_CURRENT => t('Up to date'),
    PROJECT_RELEASE_UPDATE_STATUS_NOT_CURRENT => t('Update available'),
    PROJECT_RELEASE_UPDATE_STATUS_NOT_SECURE => t('Not secure'),
  );

  return $status_list[$update_status];
}

/**
 * Fetch information about the current releases for a given project.
 *
 * This just queries the {project_release_supported_versions} table for either
 * the latest release or the recommended release, and retrieves the release
 * node. To actually recompute the latest and recommended releases for a given
 * branch, you must use project_release_find_latest_releases().
 *
 * @param $project_nid
 *   The nid of the project to find the current release for.
 * @param $api_tid
 *   The API compatibility term ID you want to search.
 * @param $recommended_major
 *   An optional major version to search. If not specified, the current
 *   recommended branch from {project_release_supported_versions} is used.
 *
 * @return
 *   A release node object or FALSE if no published releases exists that the
 *   caller can access on the requested branch of the desired project.
 */
function project_release_get_current_recommended($project_nid, $api_tid, $recommended_major = NULL) {
  $query = db_select('project_release_supported_versions', 'psrv')
    ->fields('psrv', array('recommended_release'))
    ->condition('psrv.nid', $project_nid)
    ->condition('psrv.tid', $api_tid);
  if (isset($recommended_major)) {
    $query->condition('psrv.major', $recommended_major);
  }
  else {
    $query->condition('psrv.recommended', 1);
  }
  $nid = $query->execute()->fetchField();

  if ($nid) {
    return node_load($nid);
  }
  return FALSE;
}

/**
 * Finds the latest and recommended releases for a given project and branch.
 *
 * The "latest" release just means the published release node with the highest
 * version string. The "recommended" release is the published release node
 * with the highest version string that doesn't have a "version_extra" field
 * (e.g. "beta1"). If all releases on the given branch have "extra", then the
 * recommended release will be the same as the latest release.
 *
 * @param $project_nid
 *   The node ID of the project to find the latest and recommended releases of.
 * @param $version_api
 *   The API compatibility string to search.
 * @param $version_major
 *   The major version number to search.
 * @param $access
 *   Optional boolean to indicate if node access checks should be enforced.
 *   Defaults to FALSE since the caller might not actually have access to all
 *   the releases or projects. However, this function usually has to compute
 *   the accurate values regardless of access, and consumers of this data are
 *   responsible for ensuring access.
 *
 * @return
 *  An array containing the node ID (nid) of the latest and recommended
 *  releases, and latest security update (if any) from the given branch.
 *
 * @see project_release_query_releases()
 */
function project_release_find_latest_releases($project_nid, $version_api, $version_major, $access = FALSE) {
  $latest_release = $recommended_release = $latest_security_release = 0;

  foreach (project_release_query_releases($project_nid, $version_api, $version_major, $access) as $release) {
    if (empty($latest_release)) {
      $latest_release = $release->nid;
    }
    if (empty($recommended_release) && empty($release->project_release['version_extra'])) {
      $recommended_release = $release->nid;
    }
    if (empty($latest_security_release) && project_release_is_security_update($release)) {
      $latest_security_release = $release->nid;
    }

    // If we've found everything we're looking for, break out of the loop and
    // stop inspecting release from this branch. $latest_release can't
    // possibly be empty here, so don't bother testing for it.
    if (!empty($recommended_release) && !empty($latest_security_release)) {
      break;
    }
  }

  // If we found no releases without extra (e.g. a new branch that only has
  // betas), just call the latest release the recommended one).
  if (empty($recommended_release)) {
    $recommended_release = $latest_release;
  }

  return array(
    $latest_release,
    $recommended_release,
    $latest_security_release,
  );
}

/**
 * Find releases, optionally limited to a branch and major, ordered by version.
 *
 * @param $project_nid
 *   The project node ID.
 * @param $version_api
 *   The API compatibility string.
 * @param $version_major
 *   The major version that defines the branch for the project and API term.
 * @param $access
 *   Optional boolean to indicate if node access checks should be enforced.
 *   Defaults to FALSE since the caller might not actually have access to all
 *   the releases or projects. However, this function usually has to compute
 *   the accurate values regardless of access, and consumers of this data are
 *   responsible for ensuring access.
 * @return
 *   An associative array of fully loaded nodes.
 *
 * @see project_release_find_latest_releases()
 */
function project_release_query_releases($project_nid, $version_api = NULL, $version_major = NULL, $access = FALSE) {
  $query = db_select('node', 'n');
  $query->innerJoin('project_release', 'pr', 'n.nid = pr.nid');
  $query->fields('pr');
  $query->condition('n.status', 1);
  $query->condition('pr.project_nid', $project_nid);
  if (isset($version_api)) {
    $query->condition('pr.version_api', $version_api);
  }
  if (isset($version_major)) {
    $query->condition('pr.version_major', $version_major);
  }
  if ($access) {
    $query->addTag('node_access');
  }

  $nids = $query->execute()->fetchAllAssoc('nid');
  if (empty($nids)) {
    return array();
  }
  $releases = node_load_multiple($nids);

  array_multisort(
    $columns['version_major'], SORT_DESC, SORT_NUMERIC,
    $columns['version_minor'], SORT_DESC, SORT_NUMERIC,
    $columns['version_patch'], SORT_DESC, SORT_NUMERIC,
    $columns['version_extra'], SORT_DESC, SORT_STRING,
    $nids,
    $releases);

  return array_combine($nids, $releases);
}

/**
 * Get a list of valid version strings for a project.
 */
function project_release_get_available_versions($project_nid, $api_tid = NULL) {
  // @todo Caching
  $versions = array();
  $releases = project_release_query_releases($project_nid, $api_tid, NULL, FALSE, TRUE);
  foreach ($releases as $release) {
    $versions[] = $release->project_release['version'];
  }
  uasort($versions, '_project_release_version_compare');
  return $versions;
}

/**
 * Helper function for uasort()ing version strings.
 */
function _project_release_version_compare($a, $b) {
  if ($a == $b) {
    return 0;
  }
  // Minor hack to handle Backdrop-specific contrib version numbers. This
  // shouldn't harm anyone else's sort order.
  $a = str_replace('.x-', '.9999-', $a);
  $b = str_replace('.x-', '.9999-', $b);
  return version_compare($a, $b, '>') ? -1 : 1;
}

/**
 * Determine if a release node is a security update.
 *
 * @param $node
 *   A release node object.
 *
 * @return
 *   Boolean, TRUE if $node is a security release.
 */
function project_release_is_security_update($node) {
  return !empty($node->project_release['security_update']);
}

/**
 * Determine if a release already exists with the given version.
 *
 * @param $project_nid
 *   A project node ID.
 * @param $version
 *   A string version number for a release.
 *
 * @return integer
 *   The node ID of an existing release with the given version information, or
 *   FALSE if no such release already exists.
 */
function project_release_exists($project_nid, $version) {
  return db_query("SELECT nid FROM {project_release} WHERE project_nid = :nid AND version = :version", array(':nid' => $project_nid, ':version' => $version))->fetchField();
}

/**
 * Implementation of hook_theme().
 */
function project_release_theme() {
  return array(
    'project_release_edit_table' => array(
      'file' => 'project_release.pages.inc',
      'render element' => 'api',
    ),
  );
}

/**
 * Implementation of hook_views_api().
 */
function project_release_views_api() {
  return array(
    'api' => 3,
    'path' => backdrop_get_path('module', 'project_release') . '/views',
  );
}

/**
 * Return the mapping of version_extra prefixes to version_extra_weight values.
 *
 * This mapping allows project_release to use SQL to sort releases by version,
 * even though direct string comparison doesn't work for the kinds of version
 * strings people might use (for example "1.0-unstable1" should be lower than
 * "1.0-alpha3", even though "u" comes higher in the alphabet than "a"). This
 * is similar to the logic version_compare() performs, only using this weight
 * field, we can do the comparison in SQL instead of in PHP.
 *
 * @return
 *   Associative array mapping version_extra prefixes into weights. The
 *   prefixes should be lowercase, since the query uses LOWER(version_extra)
 *   inside _project_release_update_version_extra_weights(). The special-case
 *   is the record with the key 'NULL' (should be uppercase) which doesn't
 *   correspond to a literal version_extra field, but is used for releases
 *   that do not define version_extra where the value is NULL in the database.
 *
 * @see version_compare()
 * @see _project_release_update_version_extra_weights()
 */
function project_release_get_version_extra_weight_map() {
  $default_map = array(
    'NULL' => 10, // Official releases without extra are always highest.
    'rc' => 4,
    'beta' => 3,
    'alpha' => 2,
    'unstable' => 1,
    // Anything that doesn't match will remain at weight 0, the default.
  );
  return variable_get('project_release_version_extra_weights', $default_map);
}

/**
 * Implement hook_views_default_views_alter().
 *
 * This injects project_release-specific features into views provided by the
 * project.module.
 */
function project_release_views_default_views_alter(&$views) {
  $api_versions = config_get('project_release.settings', 'api_versions');
  if (!empty($api_versions) && isset($views['project_index'])) {
    // Add release API compatibility filter to project index view.
    $views['project_index']->set_display('default');
    $views['project_index']->display_handler->set_option('relationships', array(
      'reverse_field_release_project_node' => array(
        'id' => 'reverse_field_release_project_node',
        'table' => 'node',
        'field' => 'reverse_field_release_project_node',
        'label' => 'Releases',
      ),
    ));
  }
}

/**
 * Determine whether or not a node is an release.
 *
 * @param $node
 *   A node to check.
 *
 * @return boolean
 *   Is the given node an release or not?
 */
function project_release_node_is_release($node) {
  return project_release_node_type_is_release($node->type);
}

/**
 * Determine whether or not a given node type behaves as a release.
 *
 * We just check the project_behavior_[node_type] setting for each node type
 * in the system to see if the type is configured to behave like a release.
 *
 * @param string $node_type_name
 *   The node type (machine name) to check.
 *
 * @return boolean
 *   Is the given node type a release node type or not?
 */
function project_release_node_type_is_release($node_type_name) {
  $node_type = node_type_get_type($node_type_name);
  return $node_type->settings['project_behavior'] === 'project_release';
}

/**
 * Retrieve a list of node types that are considered releases.
 *
 * @return array
 *   An array of bundle names (aka node type names) that are configured to
 *   have release nature.
 *
 * @see project_release_node_type_is_release()
 */
function project_release_release_node_types() {
  $release_node_types = array();
  $node_types = node_type_get_types();
  foreach ($node_types as $type) {
    if (project_release_node_type_is_release($type->type)) {
      $release_node_types[] = $type->type;
    }
  }
  return $release_node_types;
}

/**
 * Implements hook_project_behavior_info().
 *
 * @return array
 *   Info about the 'project_release' project behavior.
 */
function project_release_project_behavior_info() {
  return array(
    'machine name' => 'project_release',
    'label' => t('Used for project releases'),
    'settings callback' => 'project_release_project_behavior_settings',
  );
}

/**
 * Callback for hook_project_behavior_settings().
 */
function project_release_project_behavior_settings($node_type) {
  $form['project_release_version_format'] = array(
    '#type' => 'textfield',
    '#title' => t('Version format string'),
    '#default_value' => $node_type->settings['project_release_version_format'],
    '#size' => 50,
    '#maxlength' => 255,
    '#description' => PROJECT_RELEASE_VERSION_FORMAT_HELP,
    '#element_validate' => array('_project_release_validate_format_string'),
    '#pre_render' => array('_project_release_version_string_pre_render'),
    '#states' => array(
      'invisible' => array(
        ':input[name="project_behavior"]' => array('!value' => 'project_release'),
      ),
    ),
    '#parents' => array('project_release_version_format'),
  );

  return $form;
}

/**
 * Pre-render callback used in project_release_project_behavior_settings().
 */
function _project_release_version_string_pre_render($element) {
  // Make the element appear required, though it is conditionally checked.
  $element['#required'] = TRUE;
  return $element;
}

/**
 * Validates a version format string. Only alphanumeric characters and [-_.!%#]
 * are allowed. Calls form_error() on error, else returns.
 *
 * @param $element
 *   The form element for the format string.
 */
function _project_release_validate_format_string($element) {
  if (!preg_match('/^[a-zA-Z0-9_\-.!%#]*$/', $element['#value'])) {
    form_error($element, PROJECT_RELEASE_VERSION_FORMAT_VALID_MSG);
  }
}

/**
 * API for populating the metadata about releases that are rebuilt.
 *
 * @param integer $nid
 *   The node ID of the release to record a rebuild version string for.
 * @param string $rebuild_version
 *   The rebuild version string to record for the given release.
 */
function project_release_record_rebuild_metadata($nid, $rebuild_version) {
  if (db_select('project_release_node_rebuild_metadata')->condition('nid', $nid)->countQuery()->execute()->fetchField()) {
    $query = db_update('project_release_node_rebuild_metadata')
      ->fields(array(
        'rebuild_version' => $rebuild_version,
      ))
      ->condition('nid', $nid)
      ->execute();
  }
  else {
    $query = db_insert('project_release_node_rebuild_metadata')
      ->fields(array(
        'nid' => $nid,
        'rebuild_version' => $rebuild_version,
      ))
      ->execute();
  }
}
